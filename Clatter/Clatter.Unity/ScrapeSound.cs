using Clatter.Core;


namespace Clatter.Unity
{
    /// <summary>
    /// A sound generated by an scrape event and `ClatterManager`. A ScrapeSound will persist after its audio clip ends, and will try to play more scrape audio; it will be fed new audio from `ClatterManager`. A ScrapeSound will self-destruct when a scrape event actually ends, as announced by `ClatterManager`.
    /// </summary>
    public class ScrapeSound : Sound
    {
        /// <summary>
        /// Scrape audio data.
        /// </summary>
        private class ScrapeAudioData
        {
            /// <summary>
            /// The audio samples.
            /// </summary>
            public float[] data;
            /// <summary>
            /// If true, this object has been allocated and is ready to be playing.
            /// </summary>
            public bool allocated;
        }


        /// <summary>
        /// The number of cached audio samples.
        /// </summary>
        private const int NUM_NEXT_SAMPLES = 3;


        /// <summary>
        /// A cached array of pending audio data.
        /// </summary>
        private readonly ScrapeAudioData[] nextData = new ScrapeAudioData[NUM_NEXT_SAMPLES];
        /// <summary>
        /// The index of the next audio samples.
        /// </summary>
        private int nextDataIndex = -1;


        /// <summary>
        /// Update the scrape audio.
        /// </summary>
        /// <param name="samples">The new samples.</param>
        /// <param name="position">The new position of the sound.</param>
        public void UpdateAudio(Samples samples, Vector3d position)
        {
            // Move the scrape sound.
            transform.position = position.ToVector3();
            if (nextDataIndex < 0)
            {
                for (int i = 0; i < nextData.Length; i++)
                {
                    // Create and use new samples.
                    if (nextData[i] == null)
                    {
                        nextData[i] = new ScrapeAudioData()
                        {
                            data = samples.ToFloats(),
                            allocated = true
                        };
                        nextDataIndex = i;
                        return;
                    }
                    // Use unallocated samples.
                    else if (!nextData[i].allocated)
                    {
                        nextData[i].data = samples.ToFloats();
                        nextData[i].allocated = true;
                        nextDataIndex = i;
                        return;
                    }
                }
            }
        }


        protected override void OnAudioClipEnd()
        {
            // Get more samples.
            if (nextDataIndex >= 0 && nextData[nextDataIndex].allocated)
            {
                // Set the audio data.
                Play(nextData[nextDataIndex].data);
                // Un-allocate the samples.
                nextData[nextDataIndex].allocated = false;
                nextDataIndex = -1;
            }
        }
    }
}