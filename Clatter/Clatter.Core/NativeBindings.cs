/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#pragma warning disable IDE0044, IDE0049, IDE0055, IDE1006,
#pragma warning disable SA1004, SA1008, SA1023, SA1028,
#pragma warning disable SA1121, SA1134,
#pragma warning disable SA1201,
#pragma warning disable SA1300, SA1306, SA1307, SA1310, SA1313,
#pragma warning disable SA1500, SA1505, SA1507,
#pragma warning disable SA1600, SA1601, SA1604, SA1605, SA1611, SA1615, SA1649,

namespace ClatterRs {
using System;
using System.Runtime.InteropServices;

public unsafe partial class Ffi {
    private const string RustLib = "clatter_rs";
}

/// <summary>
/// Same as [<c>Vec<T></c>][<c>rust::Vec</c>], but with guaranteed <c>#[repr(C)]</c> layout
/// </summary>
[StructLayout(LayoutKind.Sequential, Size = 24)]
public unsafe struct Vec_double_t {
    public double * ptr;

    public UIntPtr len;

    public UIntPtr cap;
}

public unsafe partial class Ffi {
    /// <summary>
    /// Convolve the input by the kernel.
    ///
    /// Source: https://stackoverflow.com/a/7239016
    /// This code is a more optimized version of the source.
    /// We're not using an fft convolve because it's actually faster to convolve in-place without ndarray.
    ///
    /// - <c>input</c> The input array.
    /// - <c>kernel</c> A convolution kernel.
    /// - <c>length</c> The length of the convolved array.
    /// - <c>output</c> The output array.
    /// </summary>
    [DllImport(RustLib, ExactSpelling = true)] public static unsafe extern
    void convolve (
        Vec_double_t /*const*/ * input,
        Vec_double_t /*const*/ * kernel,
        UIntPtr length,
        Vec_double_t * output);
}

public unsafe partial class Ffi {
    [DllImport(RustLib, ExactSpelling = true)] public static unsafe extern
    void impact_frequencies (
        Vec_double_t * linear_space,
        UIntPtr length);
}

public unsafe partial class Ffi {
    /// <summary>
    /// No-op to let the C# library check if it can load this library.
    /// </summary>
    [DllImport(RustLib, ExactSpelling = true)] public static unsafe extern
    void is_ok ();
}

public unsafe partial class Ffi {
    /// <summary>
    /// Synthesize a sinusoid from mode data.
    ///
    /// - <c>power</c> The mode onset powers in dB.
    /// - <c>decay</c> The mode decay time i.e. the time in ms it takes for this mode to decay 60dB from its onset power.
    /// - <c>frequency</c> The mode frequency in Hz.
    /// - <c>resonance</c> The object's resonance value.
    /// - <c>mode_count</c> The actual length of the sinusoid.
    /// - <c>framerate</c> The audio framerate.
    /// </summary>
    [DllImport(RustLib, ExactSpelling = true)] public static unsafe extern
    void mode_sinusoid (
        double power,
        double decay,
        double frequency,
        double resonance,
        UIntPtr mode_count,
        double framerate,
        Vec_double_t * mode);
}


} /* ClatterRs */
